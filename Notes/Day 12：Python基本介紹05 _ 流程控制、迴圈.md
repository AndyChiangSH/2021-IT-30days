# Day 12：Python基本介紹05 | 流程控制、迴圈

###### tags: `2021 IT鐵人賽`

各位安安，今天講的是對任何程式語言都很重要也很基礎的**流程控制**和**迴圈**的概念，如果你先前已經學過其他程式語言了，那你一定很快就能學起來，如果你之前沒學過也沒關係，今天學完後以後在學其他程式語言時也可以受惠。

## 流程控制

想像你每天出門時，會依照條件決定要不要帶傘，你的條件是：

> 如果今天下雨機率大於80%，我出門就帶傘。

則轉換成程式碼後就會是...

```python
rain_prob = 90    # 表示下雨機率

if rain_prob > 80:
    print("出門要帶傘!")
```

這裡因為下雨機率的確大於80，所以程式會提醒你要帶傘! (這裡我用`print()`來表示行動)。

但如果下雨機率小於80呢，假如你將下雨機率改為70，你會發現程式什麼東西都沒有印，那原因就是因為我們沒告訴程式條件不成立時該怎麼做。

所以要將上面程式碼稍作修改...

```python
rain_prob = 70

if rain_prob > 80:
    print("出門要帶傘!")
else:
    print("不用帶傘了~")
```

這是人類和程式的邏輯很不一樣的地方，我們會很下意識地認為說，**如果下雨機率沒有大於80，那我們就應該不會帶傘出門**。但程式不是這樣，你一定要很清楚地告訴他如果條件不符合時該怎麼做，他才會照著你的意思走。

再來，我們可以加上稍微複雜一點的條件，比方說：

> 如果今天下雨機率大於80%，而且我不開車上班，我出門就帶傘。

轉換成程式碼後...

```python
rain_prob = 90
drive = True

if rain_prob > 80 and not drive:
    print("出門要帶傘!")
else:
    print("不用帶傘了~")
```

修但幾累...突然間出現兩個沒看過的關鍵字耶? 別緊張，我們一個個來看。

* `and`：**且**，連接兩個布林值，如果兩個布林值都是True，and後的結果才是True，否則就是False。
* `not`：**非**，將布林值反轉，簡單講就是True變成False，False變成True。

順便補充一下`or`

* `or`：**或**，連接兩個布林值，如果兩個布林值其中一個為True，or後的結果就是True，否則為False。

整理成真值表後就是底下這樣：

![](https://i.imgur.com/bHiRK4P.jpg)

Python的`and`、`or`、`not`已經算非常直白易懂了，作為比較，在C語言中會對應成`&&`、`||`、`!`。

回到上面例子，雖然說下雨機率大於80沒錯，但因為我要開車的關係，所以最後 True `and` False 的結果還是False，就不用帶傘了~

然後，我們還可以加上更多的條件：

> 如果下雨機率大於80，出門要帶傘，但如果下雨機率在60~80間，帶個帽子出門就好了。

等同於下面的程式碼...

```python
rain_prob = 70

if rain_prob > 80:
    print("出門要帶傘!")
else:
    if rain_prob > 60:
        print("帶個帽子就好")
    else:
        print("都不用帶~")
```

這是巢狀if的結構，如果第一個條件不成立(下雨機率小於等於80)，則驗證下一個條件，如果成立(下雨機率大於60)，下雨機率就真的在60~80間，則戴頂帽子就好了!

上方的程式碼還可以再簡化，就寫成...

```python
rain_prob = 70

if rain_prob > 80:
    print("出門要帶傘!")
elif rain_prob > 60:
    print("帶個帽子就好")
else:
    print("都不用帶~")

```

`elif`是 **else if** 的縮寫，中文意思上有點 "要不然..." 的含意，也就是上方條件如果不符合時，才會檢查這個條件，如果全部條件都不符合，則執行else中的程式。

跟上面的程式碼的邏輯是一模一樣的，但比較起來行數就少一行，所以盡量能用elif就用elif來簡化你的程式碼。


## 迴圈

迴圈用於處理重複性高的工作，可幫助你省下許多程式碼。

### for迴圈

假如我現在想要印出1~10，那我會這樣寫：

```python
for i in range(1, 11):
    print("i =", i)
```

執行結果：

```
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
```

我們來看看for迴圈做了什麼事。

首先這個`range(1, 11)`事實上是個產生器(generator)，但如果要講產生器是什麼，就可以花掉一天了XD，想了解產生器的話可以看我之前寫的[這篇](https://ithelp.ithome.com.tw/articles/10258195)或別人寫的[這篇](https://medium.com/ai-academy-taiwan/python-%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%89%A9%E4%BB%B6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%A2%E7%94%9F%E5%99%A8-236d19c4051e)也滿推薦的。

我們這邊就從簡，**當作**他是一個從1到10的List，就像這樣：`[1, 2, 3, ..., 10]`。

接著for迴圈就從頭開始(1)，一次取一個元素，取完後往前+1，這樣一次稱為一個**迭代**，就這樣重複執行，直到List結束(10)。

還記得昨天和前天教的容器(Collection)嗎? 他們其實都是**可迭代**的，也就是說，都可以透過for迴圈走訪一個個的元素。

```python
mylist = ["A", "B", "C", "D", "E"]

for elem in mylist:
    print(elem)
```

執行結果：

```
A
B
C
D
E
```

也可以在for迴圈中放入for迴圈，這稱之為巢狀for迴圈。

使用巢狀for迴圈就可以輕易地印出九九乘法表了!

```python
for i in range(1, 10):
    for j in range(1, 10):
        print("{} * {} = {:2d}, ".format(i, j, i*j), end="")
    print()
```

結果：

```
1 * 1 =  1, 1 * 2 =  2, 1 * 3 =  3, 1 * 4 =  4, 1 * 5 =  5, 1 * 6 =  6, 1 * 7 =  7, 1 * 8 =  8, 1 * 9 =  9, 
2 * 1 =  2, 2 * 2 =  4, 2 * 3 =  6, 2 * 4 =  8, 2 * 5 = 10, 2 * 6 = 12, 2 * 7 = 14, 2 * 8 = 16, 2 * 9 = 18,
3 * 1 =  3, 3 * 2 =  6, 3 * 3 =  9, 3 * 4 = 12, 3 * 5 = 15, 3 * 6 = 18, 3 * 7 = 21, 3 * 8 = 24, 3 * 9 = 27,
4 * 1 =  4, 4 * 2 =  8, 4 * 3 = 12, 4 * 4 = 16, 4 * 5 = 20, 4 * 6 = 24, 4 * 7 = 28, 4 * 8 = 32, 4 * 9 = 36,
5 * 1 =  5, 5 * 2 = 10, 5 * 3 = 15, 5 * 4 = 20, 5 * 5 = 25, 5 * 6 = 30, 5 * 7 = 35, 5 * 8 = 40, 5 * 9 = 45,
6 * 1 =  6, 6 * 2 = 12, 6 * 3 = 18, 6 * 4 = 24, 6 * 5 = 30, 6 * 6 = 36, 6 * 7 = 42, 6 * 8 = 48, 6 * 9 = 54,
7 * 1 =  7, 7 * 2 = 14, 7 * 3 = 21, 7 * 4 = 28, 7 * 5 = 35, 7 * 6 = 42, 7 * 7 = 49, 7 * 8 = 56, 7 * 9 = 63,
8 * 1 =  8, 8 * 2 = 16, 8 * 3 = 24, 8 * 4 = 32, 8 * 5 = 40, 8 * 6 = 48, 8 * 7 = 56, 8 * 8 = 64, 8 * 9 = 72,
9 * 1 =  9, 9 * 2 = 18, 9 * 3 = 27, 9 * 4 = 36, 9 * 5 = 45, 9 * 6 = 54, 9 * 7 = 63, 9 * 8 = 72, 9 * 9 = 81,
```

### while迴圈

while迴圈和for迴圈不同點在於，while迴圈沒有給定一個明確的範圍。while迴圈會一直執行直到條件變為False或遇到break。

剛才數1到10的while迴圈版本：

```python
i = 1
while i < 11:
    print("i =", i)
    i += 1
```

i一開始是1，所以`i < 11`這個條件是True，因此迴圈會執行print()和i+=1，但是執行到第10次時，i+=1後i就變11了，就不滿足`i < 11`了阿，所以就會跳出迴圈，結束程式。

除此之外也可以用break跳出迴圈：

```python
i = 1
while True:
    if i > 10:
        break
    print("i =", i)
    i += 1
```

就如同上一個while迴圈，當i=11時，因為滿足`i > 10`的條件，所以會執行break，跳出迴圈。

## 小結

今天教了寫程式中，很基礎卻也很重要的條件控制(if...else...)和迴圈(for、while)，以我寫程式的經驗來看，百分之七十的程式碼都是由這些組成的，就可以得知這兩個的觀念有多重要的吧!

因為篇幅有限，只能讓你快速的對Python的語法有個了解，還有很多觀念都沒有講到，所以如果你是初學程式者的話(就是連條件控制和迴圈的觀念都沒有的話)，其實我是不太建議你看我的文章學(怕誤人子弟)，可以改看其他基礎程式教學，到Google搜尋就有很多囉~ 或許我之後也會再出基礎教學的系列 (先立Flag?

畢竟我是資工系本系，又是從C語言開始學程式的，對if和for這種東西早就用到比呼吸還自然了，一時間要寫文章還真不知道要怎麼講解XD，我已經盡量用最簡單的方式去解釋了，希望能讓在座各位聽得懂，如果有不懂或覺得怎樣寫會更好的，都歡迎在底下留言哦!

明天就是Python基本介紹的最後一天了! 我將介紹函數、讀寫檔案、引用的觀念，那麼，我們明天見(๑•̀ㅁ•́๑)✧

---

如果喜歡這系列文章麻煩幫我按Like加訂閱，你的支持是我創作最大的動力~

本系列文章以及範例程式碼都同步更新在[GitHub](https://github.com/AndyChiangSH/2021-IT-30days)上，後續會持續的更新，如果喜歡也麻煩幫我按個星星吧~

有任何問題或建議，都歡迎在底下留言區提出，還請大家多多指教。